# main.py (Báº£n NÃ¢ng Cáº¥p v5.0 - Fix Logic BÃ¡o cÃ¡o & TÃ­nh nÄƒng Giao viá»‡c)
import os
import asyncio
import requests # Giá»¯ láº¡i Ä‘á»ƒ quote URL, nhÆ°ng khÃ´ng dÃ¹ng Ä‘á»ƒ request
import aiohttp # ThÆ° viá»‡n request báº¥t Ä‘á»“ng bá»™
import json
import logging # <<< THÃŠM VÃ€O
from datetime import datetime, timedelta, time

# --- Cáº¤U HÃŒNH LOGGING ---
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    handlers=[
        logging.FileHandler("bot_activity.log"), # Ghi log ra file
        logging.StreamHandler() # Hiá»ƒn thá»‹ log trÃªn console
    ]
)
logger = logging.getLogger(__name__)
# -------------------------
from dotenv import load_dotenv
from telegram import Update
from telegram.constants import ParseMode
from telegram.helpers import escape_markdown
from telegram.ext import Application, CommandHandler, MessageHandler, filters, ContextTypes
from apscheduler.schedulers.asyncio import AsyncIOScheduler
from apscheduler.jobstores.base import JobLookupError
import google.generativeai as genai

# --- Cáº¤U HÃŒNH ---
load_dotenv()
TELEGRAM_TOKEN = os.getenv("TELEGRAM_TOKEN")
ONEOFFICE_TOKEN = os.getenv("ONEOFFICE_TOKEN")
GOOGLE_API_KEY = os.getenv("GOOGLE_API_KEY")
MY_CHAT_ID = os.getenv("MY_CHAT_ID")
genai.configure(api_key=GOOGLE_API_KEY)
gemini_model = genai.GenerativeModel('gemini-2.0-flash')
ONEOFFICE_LINK = "https://innojsc.1office.vn/work"
STATUS_MAP = {"COMPLETED": "HoÃ n thÃ nh", "CANCEL": "Há»§y", "PAUSE": "Táº¡m dá»«ng"}
DEFAULT_ASSIGNEE = "Táº¡ HoÃ ng Nam"

# --- CÃC HÃ€M GIAO TIáº¾P Vá»šI 1OFFICE (Sá»­ dá»¥ng AIOHTTP) ---
async def get_tasks_data(filters_override=None):
    """Láº¥y dá»¯ liá»‡u cÃ´ng viá»‡c tá»« 1Office báº¥t Ä‘á»“ng bá»™."""
    default_filters = {"assign_ids": DEFAULT_ASSIGNEE, "status": "DOING"}
    final_filters = filters_override if filters_override else default_filters
    # KhÃ´ng cáº§n quote thá»§ cÃ´ng ná»¯a
    filters_json_string = json.dumps([final_filters])
    base_url = "https://innojsc.1office.vn/api/work/normal/gets"
    # Táº¡o má»™t dictionary chá»©a cÃ¡c tham sá»‘
    params = {
        "access_token": ONEOFFICE_TOKEN,
        "filters": filters_json_string
    }
    try:
        async with aiohttp.ClientSession() as session:
            async with session.get(base_url, params=params) as response:
                response.raise_for_status() # Tá»± Ä‘á»™ng bÃ¡o lá»—i cho cÃ¡c status 4xx, 5xx
                return await response.json(content_type=None)
    # <<< Xá»¬ LÃ Lá»–I CHI TIáº¾T >>>
    except aiohttp.ClientError as e:
        # Lá»—i liÃªn quan Ä‘áº¿n káº¿t ná»‘i máº¡ng (khÃ´ng thá»ƒ káº¿t ná»‘i, timeout, DNS, v.v.)
        logger.error(f"Lá»—i máº¡ng trong get_tasks_data: {e}")
        return None
    except json.JSONDecodeError as e:
        # Lá»—i khi API tráº£ vá» má»™t chuá»—i khÃ´ng pháº£i lÃ  JSON há»£p lá»‡
        logger.error(f"Lá»—i giáº£i mÃ£ JSON trong get_tasks_data: {e}")
        return None
    except Exception as e:
        # Báº¯t cÃ¡c lá»—i khÃ´ng lÆ°á»ng trÆ°á»›c khÃ¡c
        logger.critical(f"Lá»—i khÃ´ng xÃ¡c Ä‘á»‹nh trong get_tasks_data: {e}", exc_info=True)
        return None

async def create_and_start_task(title, end_plan, assignee_name=DEFAULT_ASSIGNEE):
    """Quy trÃ¬nh 2 bÆ°á»›c: Táº¡o vÃ  kÃ­ch hoáº¡t cÃ´ng viá»‡c, vá»›i xá»­ lÃ½ lá»—i chi tiáº¿t."""
    base_url = "https://innojsc.1office.vn/api/work/normal"
    params = {"access_token": ONEOFFICE_TOKEN}
    
    insert_payload = {
        'title': title, 
        'assign_ids': assignee_name, 
        'owner_ids': DEFAULT_ASSIGNEE,
        'end_plan': end_plan
    }
    
    try:
        async with aiohttp.ClientSession() as session:
            # BÆ°á»›c 1: Táº¡o cÃ´ng viá»‡c má»›i
            async with session.post(f"{base_url}/insert", params=params, data=insert_payload) as response:
                response.raise_for_status()
                resp_json = await response.json(content_type=None)
                if resp_json.get("error"):
                    logger.error(f"API 1Office bÃ¡o lá»—i khi táº¡o viá»‡c: {resp_json.get('message')}")
                    return None, resp_json.get("message", "Lá»—i khÃ´ng xÃ¡c Ä‘á»‹nh tá»« 1Office.")
                
                new_task_id = resp_json.get("newPost", {}).get("ID")
                if not new_task_id:
                    logger.error(f"KhÃ´ng láº¥y Ä‘Æ°á»£c ID cÃ´ng viá»‡c má»›i. Pháº£n há»“i: {resp_json}")
                    return None, "KhÃ´ng láº¥y Ä‘Æ°á»£c ID cá»§a cÃ´ng viá»‡c má»›i táº¡o."

            # BÆ°á»›c 2: KÃ­ch hoáº¡t cÃ´ng viá»‡c vá»«a táº¡o
            update_payload = {'ID': new_task_id, 'status': 'Äang thá»±c hiá»‡n', 'start_plan': datetime.now().strftime('%d/%m/%Y')}
            async with session.post(f"{base_url}/update", params=params, data=update_payload) as update_res:
                update_res.raise_for_status()
                update_json = await update_res.json(content_type=None)
                if not update_json.get("error"):
                    logger.info(f"ÄÃ£ táº¡o vÃ  kÃ­ch hoáº¡t thÃ nh cÃ´ng cÃ´ng viá»‡c ID: {new_task_id}")
                    return new_task_id, None
                else:
                    logger.warning(f"ÄÃ£ táº¡o viá»‡c {new_task_id} nhÆ°ng khÃ´ng kÃ­ch hoáº¡t Ä‘Æ°á»£c: {update_json.get('message')}")
                    return new_task_id, "ÄÃ£ táº¡o nhÆ°ng chÆ°a kÃ­ch hoáº¡t Ä‘Æ°á»£c."

    except aiohttp.ClientError as e:
        logger.error(f"Lá»—i máº¡ng trong create_and_start_task: {e}")
        return None, "Lá»—i káº¿t ná»‘i máº¡ng khi táº¡o viá»‡c."
    except json.JSONDecodeError as e:
        logger.error(f"Lá»—i giáº£i mÃ£ JSON trong create_and_start_task: {e}")
        return None, "Há»‡ thá»‘ng 1Office Ä‘Ã£ tráº£ vá» dá»¯ liá»‡u khÃ´ng há»£p lá»‡."
    except Exception as e:
        logger.critical(f"Lá»—i khÃ´ng xÃ¡c Ä‘á»‹nh trong create_and_start_task: {e}", exc_info=True)
        return None, "ÄÃ£ cÃ³ lá»—i há»‡ thá»‘ng khi tÃ´i cá»‘ gáº¯ng táº¡o viá»‡c cho báº¡n."

async def update_task(task_id, payload):
    """HÃ m cáº­p nháº­t cÃ´ng viá»‡c tá»•ng quÃ¡t, vá»›i xá»­ lÃ½ lá»—i chi tiáº¿t."""
    base_url = "https://innojsc.1office.vn/api/work/normal/update"
    params = {"access_token": ONEOFFICE_TOKEN}
    payload['ID'] = task_id
    try:
        async with aiohttp.ClientSession() as session:
            async with session.post(base_url, params=params, data=payload) as response:
                response.raise_for_status()
                resp_json = await response.json(content_type=None)
                if not resp_json.get("error"):
                    logger.info(f"Cáº­p nháº­t thÃ nh cÃ´ng task {task_id} vá»›i payload: {payload}")
                    return True
                else:
                    logger.error(f"API 1Office bÃ¡o lá»—i khi cáº­p nháº­t task {task_id}: {resp_json.get('message')}")
                    return False
    except aiohttp.ClientError as e:
        logger.error(f"Lá»—i máº¡ng khi cáº­p nháº­t task {task_id}: {e}")
        return False
    except Exception as e:
        logger.critical(f"Lá»—i khÃ´ng xÃ¡c Ä‘á»‹nh khi cáº­p nháº­t task {task_id}: {e}", exc_info=True)
        return False

async def batch_update_tasks(task_updates: list):
    """
    Thá»±c thi nhiá»u lá»‡nh cáº­p nháº­t cÃ´ng viá»‡c má»™t cÃ¡ch Ä‘á»“ng thá»i (song song).
    `task_updates` lÃ  má»™t danh sÃ¡ch cÃ¡c tuple, má»—i tuple chá»©a (task_id, payload).
    """
    # Táº¡o má»™t danh sÃ¡ch cÃ¡c coroutine (cÃ¡c hÃ m async chÆ°a Ä‘Æ°á»£c thá»±c thi)
    coroutines = [update_task(task_id, payload) for task_id, payload in task_updates]
    
    # asyncio.gather sáº½ cháº¡y táº¥t cáº£ cÃ¡c coroutine song song vÃ  Ä‘á»£i chÃºng hoÃ n thÃ nh.
    # return_exceptions=True lÃ  ráº¥t quan trá»ng: nÃ³ Ä‘áº£m báº£o ráº±ng náº¿u má»™t tÃ¡c vá»¥ tháº¥t báº¡i,
    # cÃ¡c tÃ¡c vá»¥ khÃ¡c váº«n tiáº¿p tá»¥c cháº¡y thay vÃ¬ lÃ m sáº­p toÃ n bá»™ batch.
    results = await asyncio.gather(*coroutines, return_exceptions=True)
    return results

def format_tasks_message(data, title="CÃ¡c cÃ´ng viá»‡c hiá»‡n táº¡i cá»§a báº¡n:"):
    """Äá»‹nh dáº¡ng dá»¯ liá»‡u cÃ´ng viá»‡c thÃ nh tin nháº¯n Ä‘áº¹p."""
    if not data or data.get("total_item", 0) == 0:
        return f"ğŸ‰ Tuyá»‡t vá»i! {title.split(':')[0]} khÃ´ng cÃ³ cÃ´ng viá»‡c nÃ o khá»›p."
    message = f"*{escape_markdown(title, version=2)}*\n\n"
    tasks = data.get("data", [])
    tasks.sort(key=lambda t: (
        "QuÃ¡ háº¡n" not in t.get('deadline_list', ''),
        "CÃ²n 0 ngÃ y" not in t.get('deadline_list', ''),
        t.get('end_plan', '9999-99-99')
    ))
    for task in tasks:
        task_title = escape_markdown(task['title'].strip(), version=2)
        end_plan = escape_markdown(task.get('end_plan', 'N/A'), version=2)
        task_id = str(task['ID'])
        deadline_info = task.get('deadline_list', '')
        emoji = "ğŸ”´" if "QuÃ¡ háº¡n" in deadline_info else ("ğŸŸ " if "CÃ²n 0 ngÃ y" in deadline_info else "ğŸŸ¢")
        message += f"{emoji} *{task_title}*\n  _Háº¡n chÃ³t: {end_plan}_ \\| _{escape_markdown(deadline_info, version=2)}_\n  `ID: {task_id}`\n\n"
    message += f"\\-\\-\\-\n[ğŸ”— Truy cáº­p 1Office Ä‘á»ƒ quáº£n lÃ½ chi tiáº¿t]({ONEOFFICE_LINK})"
    return message

# --- "Bá»˜ NÃƒO" GEMINI ÄÃƒ NÃ‚NG Cáº¤P ---
async def ask_gemini_for_intent(user_message, tasks_data, last_task_id=None):
    """Táº§ng 1: PhÃ¢n loáº¡i Ã½ Ä‘á»‹nh, há»— trá»£ Ä‘a Ã½ Ä‘á»‹nh, ngá»¯ cáº£nh vÃ  cÃ¡c tÃ­nh nÄƒng má»Ÿ rá»™ng."""
    today = datetime.now()
    priority_context = ""
    if last_task_id:
        last_task_info = next((task for task in tasks_data if task['ID'] == last_task_id), None)
        priority_context = f"""### NGá»® Cáº¢NH Æ¯U TIÃŠN ###
NgÆ°á»i dÃ¹ng vá»«a tÆ°Æ¡ng tÃ¡c vá»›i cÃ´ng viá»‡c: ID {last_task_id} - "{last_task_info['title'] if last_task_info else 'KhÃ´ng rÃµ'}". HÃ£y Æ°u tiÃªn nÃ³ náº¿u há» nÃ³i "viá»‡c Ä‘Ã³"."""
    prompt = f"""
    Báº¡n lÃ  má»™t AI Ä‘iá»u phá»‘i thÃ´ng minh. PhÃ¢n tÃ­ch tin nháº¯n Ä‘á»ƒ xÃ¡c Ä‘á»‹nh má»™t hoáº·c NHIá»€U hÃ nh Ä‘á»™ng.
    HÃ´m nay lÃ  {today.strftime('%d/%m/%Y')}.
    {priority_context}
    DANH SÃCH CÃ”NG VIá»†C ÄANG LÃ€M: {json.dumps(tasks_data, indent=2, ensure_ascii=False)}
    TIN NHáº®N: "{user_message}"
    PhÃ¢n tÃ­ch vÃ  tráº£ vá» JSON theo Ä‘á»‹nh dáº¡ng: {{{{ "actions": [{{ "intent": "...", "details": {{...}} }}] }}}}.
    CÃ¡c loáº¡i intent vÃ  details:
    1.  Há»i cÃ´ng viá»‡c: {{{{ "intent": "get_tasks", "details": {{}} }}}}
    2.  Há»i cÃ´ng viá»‡c Æ°u tiÃªn: {{{{ "intent": "get_prioritized_tasks", "details": {{"sort_by": "deadline_asc"}} }}}} (vd: "viá»‡c nÃ o gáº¥p nháº¥t?")
    3.  TÃ³m táº¯t/BÃ¡o cÃ¡o cÃ´ng viá»‡c: {{{{ "intent": "get_summary", "details": {{"period": "this_week"}} }}}} (vd: "tuáº§n nÃ y xong máº¥y viá»‡c?")
    4.  Cáº­p nháº­t tráº¡ng thÃ¡i: {{{{ "intent": "update_status", "details": {{"tasks": [{{"task_id": "[ID]", "new_status": "[STATUS_ID]"}}]}} }}}} (STATUS_ID: COMPLETED, CANCEL, PAUSE)
    5.  Äáº·t láº¡i deadline (ngÃ y cá»¥ thá»ƒ): {{{{ "intent": "set_deadline", "details": {{"task_id": "[ID]", "new_end_plan": "dd/mm/YYYY"}} }}}}
    6.  Gia háº¡n deadline (thÃªm thá»i gian): {{{{ "intent": "extend_deadline", "details": {{"task_id": "[ID]", "duration": {{"days": 3}}}} }}}}
    7.  Táº¡o cÃ´ng viá»‡c: {{{{ "intent": "create_task", "details": {{"tasks": [{{"title": "tÃªn", "end_plan": null, "assignee": "LÃª ThÃºy Anh hoáº·c null"}}]}} }}}}
    8.  LÃ m rÃµ viá»‡c táº¡o má»›i: {{{{ "intent": "clarify_creation", "details": {{...}} }}}}
    9.  KhÃ´ng rÃµ: {{{{ "intent": "unknown", "details": {{}} }}}}
    Quy táº¯c quan trá»ng:
    - PhÃ¢n biá»‡t rÃµ "set_deadline" (Ä‘áº·t má»™t ngÃ y cá»¥ thá»ƒ nhÆ° 'sang ngÃ y mai') vÃ  "extend_deadline" (cá»™ng thÃªm thá»i gian vÃ o deadline CÅ¨ nhÆ° 'thÃªm 2 ngÃ y').
    - Vá»›i "set_deadline", hÃ£y tÃ­nh toÃ¡n ngÃ y cuá»‘i cÃ¹ng dá»±a trÃªn ngÃ y hÃ´m nay. VÃ­ dá»¥: náº¿u hÃ´m nay lÃ  08/08/2025, "ngÃ y mai" lÃ  "09/08/2025".
    - Vá»›i "create_task", náº¿u khÃ´ng cÃ³ deadline, tráº£ vá» "end_plan": null. Náº¿u khÃ´ng cÃ³ ngÆ°á»i thá»±c hiá»‡n, tráº£ vá» "assignee": null.
    - "task_id": "LAST_CREATED" Ä‘Æ°á»£c dÃ¹ng khi hÃ nh Ä‘á»™ng trÃªn viá»‡c vá»«a táº¡o trong cÃ¹ng cÃ¢u lá»‡nh.
    - "ngÃ y mai"={(today + timedelta(days=1)).strftime('%d/%m/%Y')}, "ngÃ y kia"={(today + timedelta(days=2)).strftime('%d/%m/%Y')}.
    - Náº¿u khÃ´ng thá»ƒ xÃ¡c Ä‘á»‹nh, tráº£ vá» actions rá»—ng.
    """
    response_text = "" # Khá»Ÿi táº¡o Ä‘á»ƒ dÃ¹ng trong khá»‘i except
    try:
        response = await gemini_model.generate_content_async(prompt)
        response_text = response.text
        cleaned_response = response_text.strip().replace('```json', '').replace('```', '').strip()
        return json.loads(cleaned_response)
    # <<< Xá»¬ LÃ Lá»–I CHI TIáº¾T >>>
    except json.JSONDecodeError as e:
        logger.error(f"Lá»—i giáº£i mÃ£ JSON tá»« Gemini (Intent): {e}. Pháº£n há»“i nháº­n Ä‘Æ°á»£c: {response_text}")
        return {"actions": [{"intent": "unknown", "details": {}}]}
    except Exception as e:
        # CÃ¡c lá»—i khÃ¡c tá»« thÆ° viá»‡n cá»§a Google (vÃ­ dá»¥: bá»‹ rate limit, lá»—i xÃ¡c thá»±c, v.v.)
        logger.critical(f"Lá»—i khÃ´ng xÃ¡c Ä‘á»‹nh tá»« Gemini (Intent): {e}", exc_info=True)
        return {"actions": [{"intent": "unknown", "details": {}}]}

async def ask_gemini_to_parse_date(user_message):
    """
    PhÃ¢n tÃ­ch thÃ´ng Ä‘iá»‡p ngÆ°á»i dÃ¹ng Ä‘á»ƒ láº¥y ra ngÃ y thÃ¡ng vá»›i prompt chi tiáº¿t hÆ¡n,
    xá»­ lÃ½ ngÃ y tÆ°Æ¡ng Ä‘á»‘i, thá»© trong tuáº§n vÃ  "X ngÃ y ná»¯a".
    """
    today = datetime.now()
    # TÃ­nh toÃ¡n sáºµn cÃ¡c ngÃ y trong tuáº§n tá»›i Ä‘á»ƒ lÃ m vÃ­ dá»¥ cho AI
    next_week_monday = today + timedelta(days=-today.weekday(), weeks=1)
    prompt = f"""
Báº¡n lÃ  má»™t trá»£ lÃ½ chuyÃªn gia phÃ¢n tÃ­ch ngÃ y thÃ¡ng. Nhiá»‡m vá»¥ cá»§a báº¡n lÃ  Ä‘á»c má»™t chuá»—i vÄƒn báº£n tá»« ngÆ°á»i dÃ¹ng vÃ  tráº£ vá» má»™t ngÃ y duy nháº¥t á»Ÿ Ä‘á»‹nh dáº¡ng "dd/mm/YYYY".
### THÃ”NG TIN NGá»® Cáº¢NH
- HÃ´m nay lÃ : *{today.strftime('%A, %d/%m/%Y')}* (Tá»©c lÃ  Thá»© {today.weekday() + 2 if today.weekday() < 6 else 'Chá»§ Nháº­t'})
### QUY Táº®C VÃ€ VÃ Dá»¤
1.  **NgÃ y tÆ°Æ¡ng Ä‘á»‘i Ä‘Æ¡n giáº£n:**
    - "hÃ´m nay" -> {today.strftime('%d/%m/%Y')}
    - "ngÃ y mai" -> {(today + timedelta(days=1)).strftime('%d/%m/%Y')}
    - "ngÃ y kia" -> {(today + timedelta(days=2)).strftime('%d/%m/%Y')}
2.  **Thá»© trong tuáº§n nÃ y:** Náº¿u ngÆ°á»i dÃ¹ng nÃ³i má»™t thá»© trong tuáº§n mÃ  ngÃ y Ä‘Ã³ chÆ°a trÃ´i qua, hÃ£y tÃ­nh cho tuáº§n hiá»‡n táº¡i.
    - VÃ­ dá»¥: Náº¿u hÃ´m nay lÃ  Thá»© 2, "thá»© 6" cÃ³ nghÄ©a lÃ  thá»© 6 cá»§a tuáº§n nÃ y.
3.  **Thá»© trong tuáº§n sau:** Náº¿u ngÆ°á»i dÃ¹ng nÃ³i "thá»© X tuáº§n sau" hoáº·c thá»© Ä‘Ã³ Ä‘Ã£ trÃ´i qua trong tuáº§n nÃ y, hÃ£y tÃ­nh cho tuáº§n káº¿ tiáº¿p.
    - VÃ­ dá»¥: Náº¿u hÃ´m nay lÃ  Thá»© 6, "thá»© 3" sáº½ Ä‘Æ°á»£c hiá»ƒu lÃ  thá»© 3 cá»§a tuáº§n sau.
    - CÃ¡c ngÃ y cá»§a tuáº§n sau Ä‘Æ°á»£c tÃ­nh nhÆ° sau:
        - "thá»© 2 tuáº§n sau" -> {next_week_monday.strftime('%d/%m/%Y')}
        - "thá»© 3 tuáº§n sau" -> {(next_week_monday + timedelta(days=1)).strftime('%d/%m/%Y')}
        - "thá»© 6 tuáº§n sau" -> {(next_week_monday + timedelta(days=4)).strftime('%d/%m/%Y')}
4.  **<<< QUY Táº®C Má»šI >>> Khoáº£ng thá»i gian tÆ°Æ¡ng Ä‘á»‘i (sá»‘ ngÃ y):**
    - Náº¿u ngÆ°á»i dÃ¹ng nÃ³i "X ngÃ y ná»¯a" hoáº·c "sau X ngÃ y", hÃ£y láº¥y ngÃ y hÃ´m nay cá»™ng thÃªm X ngÃ y.
    - VÃ­ dá»¥: "3 ngÃ y ná»¯a" -> {(today + timedelta(days=3)).strftime('%d/%m/%Y')}
    - VÃ­ dá»¥: "sau 10 ngÃ y" -> {(today + timedelta(days=10)).strftime('%d/%m/%Y')}
### YÃŠU Cáº¦U
Dá»±a vÃ o cÃ¡c quy táº¯c trÃªn, hÃ£y phÃ¢n tÃ­ch cÃ¢u cá»§a ngÆ°á»i dÃ¹ng vÃ  **chá»‰ tráº£ vá» ngÃ y thÃ¡ng á»Ÿ Ä‘á»‹nh dáº¡ng "dd/mm/YYYY"**. Náº¿u khÃ´ng thá»ƒ xÃ¡c Ä‘á»‹nh, hÃ£y tráº£ vá» chá»¯ "null".
**CÃ¢u cá»§a ngÆ°á»i dÃ¹ng:** "{user_message}"
"""
    try:
        response = await gemini_model.generate_content_async(prompt)
        cleaned_response = response.text.strip().replace('```json', '').replace('```', '').replace('"', '').strip()
        return cleaned_response if cleaned_response != "null" else None
    except Exception as e:
        print(f"Lá»—i Gemini (Parse Date): {e}")
        return None

async def ask_gemini_for_related_task_suggestion(task_title: str):
    prompt = f"""
    Báº¡n lÃ  má»™t trá»£ lÃ½ quáº£n lÃ½ dá»± Ã¡n. NgÆ°á»i dÃ¹ng vá»«a táº¡o cÃ´ng viá»‡c cÃ³ tiÃªu Ä‘á»: "{task_title}".
    Dá»±a vÃ o tiÃªu Ä‘á» nÃ y, hÃ£y gá»£i Ã½ má»™t cÃ´ng viá»‡c phá»¥ hoáº·c cÃ´ng viá»‡c káº¿ tiáº¿p há»£p lÃ½.
    VÃ­ dá»¥: "Thiáº¿t káº¿ banner" -> "In áº¥n banner". "Viáº¿t ká»‹ch báº£n video" -> "Quay video theo ká»‹ch báº£n".
    Chá»‰ tráº£ vá» JSON: {{{{ "suggestion": "TÃªn cÃ´ng viá»‡c Ä‘Æ°á»£c gá»£i Ã½" }}}} hoáº·c {{{{ "suggestion": null }}}}.
    """
    try:
        response = await gemini_model.generate_content_async(prompt)
        cleaned_response = response.text.strip().replace('```json', '').replace('```', '').strip()
        return json.loads(cleaned_response)
    except Exception:
        return {"suggestion": None}

# --- CÃC HÃ€M TIá»†N ÃCH ---
def validate_task_id(task_id_to_check: int, all_tasks: list) -> bool:
    """Kiá»ƒm tra xem má»™t task_id cÃ³ tá»“n táº¡i trong danh sÃ¡ch cÃ´ng viá»‡c khÃ´ng."""
    if not all_tasks:
        return False
    return any(task['ID'] == task_id_to_check for task in all_tasks)

def get_date_range_for_period(period: str):
    today = datetime.now()
    if period == "today": return today, today
    if period == "this_week":
        start_date = today - timedelta(days=today.weekday())
        return start_date, start_date + timedelta(days=6)
    if period == "this_month":
        start_date = today.replace(day=1)
        next_month = start_date.replace(day=28) + timedelta(days=4)
        return start_date, next_month - timedelta(days=next_month.day)
    return None, None

# --- CÃC HÃ€M Xá»¬ LÃ LUá»’NG (FLOW) ---
async def start(update: Update, context: ContextTypes.DEFAULT_TYPE):
    await update.message.reply_text("Xin chÃ o! TÃ´i lÃ  trá»£ lÃ½ áº£o v5.0. TÃ´i Ä‘Ã£ sáºµn sÃ ng. GÃµ /help Ä‘á»ƒ xem lá»‡nh.")

async def help_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    help_text = """*CÃ¡c lá»‡nh báº¡n cÃ³ thá»ƒ dÃ¹ng:*
`/start` - Khá»Ÿi Ä‘á»™ng láº¡i bot
`/tasks` - Xem cÃ¡c cÃ´ng viá»‡c Ä‘ang lÃ m
`/help` - Xem tin nháº¯n nÃ y
`/set_reminders HH:MM HH:MM...` - Äáº·t lá»‹ch nháº¯c nhá»Ÿ cÃ¡ nhÃ¢n
`/clear_reminders` - XÃ³a lá»‹ch nháº¯c nhá»Ÿ cÃ¡ nhÃ¢n
... vÃ  nhiá»u cÃ¢u lá»‡nh tá»± nhiÃªn khÃ¡c!"""
    await update.message.reply_text(escape_markdown(help_text, version=2), parse_mode=ParseMode.MARKDOWN_V2)

async def handle_message(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user_message = update.message.text
    if 'clarification_needed' in context.user_data or ('pending_tasks_queue' in context.user_data and context.user_data['pending_tasks_queue']):
        if 'clarification_needed' in context.user_data: await handle_clarification_response(update, context)
        else: await fill_task_details_flow(update, context)
        return
    tasks_raw_data = await get_tasks_data()
    last_task_id = context.user_data.get('last_interaction_task_id')
    response_data = await ask_gemini_for_intent(user_message, tasks_raw_data.get("data", []) if tasks_raw_data else [], last_task_id)
    actions = response_data.get("actions", [])
    if not actions:
        await update.message.reply_text("Xin lá»—i, tÃ´i chÆ°a hiá»ƒu Ã½ báº¡n láº¯m.")
        return
    last_created_id_in_loop = None
    for action in actions:
        intent = action.get("intent")
        details = action.get("details", {})
        if intent in ["update_status", "extend_deadline", "set_deadline"]:
            tasks_to_process = details.get("tasks", []) if intent == "update_status" else [details]
            for task in tasks_to_process:
                if task.get("task_id") == "LAST_CREATED":
                    if last_created_id_in_loop: task["task_id"] = last_created_id_in_loop
                    else: await update.message.reply_text("Lá»—i: KhÃ´ng tÃ¬m tháº¥y 'cÃ´ng viá»‡c vá»«a táº¡o'."); continue
        if intent == "get_tasks": await get_prioritized_tasks_flow(update, context)
        elif intent == "get_prioritized_tasks": await get_prioritized_tasks_flow(update, context)
        elif intent == "get_summary": await get_summary_flow(update, context, details)
        elif intent == "update_status": await update_status_flow(update, context, details)
        elif intent == "set_deadline": await set_deadline_flow(update, context, details)
        elif intent == "extend_deadline": await extend_deadline_flow(update, context, details)
        elif intent == "create_task":
            newly_created_ids, created_tasks = await create_task_flow(update, context, details)
            if newly_created_ids:
                last_created_id_in_loop = newly_created_ids[-1]
                context.user_data['last_interaction_task_id'] = last_created_id_in_loop
                if created_tasks:
                    last_created_title = created_tasks[-1].get('title')
                    suggestion_data = await ask_gemini_for_related_task_suggestion(last_created_title)
                    if suggestion_data and suggestion_data.get("suggestion"):
                        await update.message.reply_text(f"ğŸ’¡ *Gá»£i Ã½:* Báº¡n cÃ³ muá»‘n táº¡o thÃªm viá»‡c: '{suggestion_data.get('suggestion')}' khÃ´ng?")
        elif intent == "clarify_creation": await clarify_creation_flow(update, context, details)
        elif intent == "unknown": await update.message.reply_text("Xin lá»—i, tÃ´i chÆ°a hiá»ƒu Ã½ báº¡n láº¯m.")

async def create_task_flow(update: Update, context: ContextTypes.DEFAULT_TYPE, details: dict):
    tasks_to_create = details.get("tasks", [])
    if not tasks_to_create:
        await update.message.reply_text("TÃ´i khÃ´ng phÃ¢n tÃ­ch Ä‘Æ°á»£c viá»‡c báº¡n muá»‘n táº¡o.")
        return [], []
    tasks_with_deadline, tasks_without_deadline = [], []
    for task in tasks_to_create:
        title = task.get("title", "").strip() # <<< SANITIZE: LÃ m sáº¡ch title
        end_plan = task.get("end_plan")
        # <<< XÃC THá»°C >>>
        if not title: continue # Bá» qua náº¿u khÃ´ng cÃ³ tiÃªu Ä‘á»
        if end_plan:
            try:
                datetime.strptime(end_plan, '%d/%m/%Y') # XÃ¡c thá»±c Ä‘á»‹nh dáº¡ng ngÃ y
                tasks_with_deadline.append(task)
            except (ValueError, TypeError):
                # Náº¿u ngÃ y sai Ä‘á»‹nh dáº¡ng, coi nhÆ° khÃ´ng cÃ³ deadline
                task['end_plan'] = None
                tasks_without_deadline.append(task)
        else:
            tasks_without_deadline.append(task)
    created_tasks_messages, newly_created_ids, created_tasks_info = [], [], []
    for task in tasks_with_deadline:
        assignee = task.get("assignee") or DEFAULT_ASSIGNEE
        new_id, error = await create_and_start_task(task['title'], task['end_plan'], assignee)
        if new_id:
            title, end_plan = escape_markdown(task['title'], version=2), escape_markdown(task['end_plan'], version=2)
            created_tasks_messages.append(f"ğŸ”¹ *{title}*\n  _Háº¡n chÃ³t: {end_plan}_\n  `(ID: {new_id})`")
            newly_created_ids.append(new_id)
            created_tasks_info.append(task)
    if created_tasks_messages: await update.message.reply_text(f"âœ… OK, tÃ´i Ä‘Ã£ táº¡o vÃ  báº¯t Ä‘áº§u {len(created_tasks_messages)} cÃ´ng viá»‡c:\n\n" + "\n\n".join(created_tasks_messages), parse_mode=ParseMode.MARKDOWN_V2)
    if tasks_without_deadline:
        context.user_data['pending_tasks_queue'] = tasks_without_deadline
        await update.message.reply_text(f"Cháº¯c cháº¯n rá»“i. CÃ´ng viá»‡c '{tasks_without_deadline[0]['title']}' cáº§n hoÃ n thÃ nh trÆ°á»›c khi nÃ o váº­y báº¡n?")
    return newly_created_ids, created_tasks_info

async def get_prioritized_tasks_flow(update: Update, context: ContextTypes.DEFAULT_TYPE):
    await update.message.reply_text("Äang kiá»ƒm tra vÃ  sáº¯p xáº¿p cÃ¡c cÃ´ng viá»‡c cá»§a báº¡n...")
    tasks_data = await get_tasks_data()
    # <<< THÃ”NG BÃO Lá»–I THÃ‚N THIá»†N >>>
    if tasks_data is None:
        await update.message.reply_text("Ráº¥t tiáº¿c, tÃ´i khÃ´ng thá»ƒ káº¿t ná»‘i Ä‘áº¿n há»‡ thá»‘ng 1Office lÃºc nÃ y. Báº¡n vui lÃ²ng thá»­ láº¡i sau nhÃ©. ğŸ› ï¸")
        return # Dá»«ng hÃ m táº¡i Ä‘Ã¢y
    message_text = format_tasks_message(tasks_data, title="ÄÃ¢y lÃ  cÃ¡c cÃ´ng viá»‡c Ä‘Æ°á»£c sáº¯p xáº¿p theo Ä‘á»™ Æ°u tiÃªn:")
    await update.message.reply_text(message_text, parse_mode=ParseMode.MARKDOWN_V2)

async def set_deadline_flow(update: Update, context: ContextTypes.DEFAULT_TYPE, details: dict):
    task_id_raw = details.get("task_id")
    new_end_plan_raw = details.get("new_end_plan")
    # 1. XÃ¡c thá»±c (Validate)
    if not task_id_raw or not new_end_plan_raw:
        await update.message.reply_text("TÃ´i chÆ°a rÃµ báº¡n muá»‘n Ä‘áº·t láº¡i deadline cho viá»‡c nÃ o hoáº·c vÃ o ngÃ y nÃ o.")
        return
    try:
        # Äáº£m báº£o task_id lÃ  má»™t sá»‘ nguyÃªn
        task_id = int(task_id_raw)
        # Äáº£m báº£o new_end_plan Ä‘Ãºng Ä‘á»‹nh dáº¡ng dd/mm/YYYY
        datetime.strptime(new_end_plan_raw, '%d/%m/%Y')
    except (ValueError, TypeError):
        await update.message.reply_text("ThÃ´ng tin khÃ´ng há»£p lá»‡. ID cÃ´ng viá»‡c hoáº·c Ä‘á»‹nh dáº¡ng ngÃ y thÃ¡ng cÃ³ váº» khÃ´ng Ä‘Ãºng.")
        return
    tasks_data = await get_tasks_data()
    if not tasks_data:
        # ThÃ´ng bÃ¡o lá»—i nÃ y Ä‘Ã£ Ä‘Æ°á»£c thÃªm vÃ o get_prioritized_tasks_flow, 
        # nhÆ°ng thÃªm á»Ÿ Ä‘Ã¢y cÅ©ng tá»‘t Ä‘á»ƒ Ä‘áº£m báº£o an toÃ n.
        await update.message.reply_text("KhÃ´ng thá»ƒ láº¥y danh sÃ¡ch cÃ´ng viá»‡c Ä‘á»ƒ xÃ¡c nháº­n.")
        return

    all_tasks = tasks_data.get("data", [])
    # <<< KIá»‚M TRA Sá»° Tá»’N Táº I Cá»¦A TASK ID >>>
    if not validate_task_id(task_id, all_tasks):
        await update.message.reply_text(f"Ráº¥t tiáº¿c, tÃ´i khÃ´ng tÃ¬m tháº¥y cÃ´ng viá»‡c nÃ o cÃ³ ID lÃ  {task_id}. Báº¡n cÃ³ thá»ƒ dÃ¹ng lá»‡nh /tasks Ä‘á»ƒ kiá»ƒm tra láº¡i nhÃ©.")
        return
    # <<< Káº¾T THÃšC KIá»‚M TRA >>>
    task_title = next((task['title'] for task in all_tasks if task['ID'] == task_id), "cÃ´ng viá»‡c Ä‘Ã³")
    if await update_task(task_id, {'end_plan': new_end_plan_raw}):
        escaped_title = escape_markdown(task_title, version=2)
        escaped_date = escape_markdown(new_end_plan_raw, version=2)
        await update.message.reply_text(f"âœ… OK, tÃ´i Ä‘Ã£ Ä‘áº·t láº¡i deadline cho '{escaped_title}' thÃ nh *{escaped_date}*\\.", parse_mode=ParseMode.MARKDOWN_V2)
        context.user_data['last_interaction_task_id'] = task_id
    else:
        await update.message.reply_text(f"Ráº¥t tiáº¿c, cÃ³ lá»—i khi cáº­p nháº­t deadline cho ID {task_id}\\.")

async def extend_deadline_flow(update: Update, context: ContextTypes.DEFAULT_TYPE, details: dict):
    """Xá»­ lÃ½ gia háº¡n deadline, cÃ³ kiá»ƒm tra sá»± tá»“n táº¡i cá»§a ID."""
    task_id_raw = details.get("task_id")
    duration = details.get("duration", {})
    days_to_add_raw = duration.get("days")

    # 1. XÃ¡c thá»±c kiá»ƒu dá»¯ liá»‡u
    if not task_id_raw or not days_to_add_raw:
        await update.message.reply_text("TÃ´i chÆ°a rÃµ báº¡n muá»‘n gia háº¡n viá»‡c nÃ o vÃ  trong bao lÃ¢u.")
        return

    try:
        task_id = int(task_id_raw)
        days_to_add = int(days_to_add_raw)
        if days_to_add <= 0:
            await update.message.reply_text("Sá»‘ ngÃ y gia háº¡n pháº£i lÃ  má»™t sá»‘ dÆ°Æ¡ng nhÃ©.")
            return
    except (ValueError, TypeError):
        await update.message.reply_text("ThÃ´ng tin khÃ´ng há»£p lá»‡. ID cÃ´ng viá»‡c hoáº·c sá»‘ ngÃ y gia háº¡n cÃ³ váº» khÃ´ng Ä‘Ãºng.")
        return

    # 2. Láº¥y danh sÃ¡ch cÃ´ng viá»‡c Ä‘á»ƒ kiá»ƒm tra
    tasks_data = await get_tasks_data()
    if not tasks_data:
        await update.message.reply_text("Ráº¥t tiáº¿c, tÃ´i khÃ´ng thá»ƒ láº¥y danh sÃ¡ch cÃ´ng viá»‡c Ä‘á»ƒ kiá»ƒm tra.")
        return
    
    all_tasks = tasks_data.get("data", [])

    # 3. <<< KIá»‚M TRA Sá»° Tá»’N Táº I Cá»¦A TASK ID >>>
    if not validate_task_id(task_id, all_tasks):
        await update.message.reply_text(f"Ráº¥t tiáº¿c, tÃ´i khÃ´ng tÃ¬m tháº¥y cÃ´ng viá»‡c nÃ o cÃ³ ID lÃ  {task_id}. Báº¡n cÃ³ thá»ƒ dÃ¹ng lá»‡nh /tasks Ä‘á»ƒ kiá»ƒm tra láº¡i nhÃ©.")
        return

    # 4. Tiáº¿n hÃ nh gia háº¡n náº¿u ID há»£p lá»‡
    task_info = next((task for task in all_tasks if task['ID'] == task_id), None)
    if not task_info.get('end_plan'):
        await update.message.reply_text(f"CÃ´ng viá»‡c '{task_info['title']}' khÃ´ng cÃ³ deadline cÅ© Ä‘á»ƒ gia háº¡n.")
        return

    try:
        old_deadline = datetime.strptime(task_info['end_plan'], '%d/%m/%Y')
        new_deadline_str = (old_deadline + timedelta(days=days_to_add)).strftime('%d/%m/%Y')
        
        if await update_task(task_id, {'end_plan': new_deadline_str}):
            task_title = escape_markdown(task_info['title'], version=2)
            await update.message.reply_text(f"âœ… OK, tÃ´i Ä‘Ã£ gia háº¡n cho '{task_title}' thÃªm {days_to_add} ngÃ y, deadline má»›i lÃ  *{escape_markdown(new_deadline_str, version=2)}*\\.", parse_mode=ParseMode.MARKDOWN_V2)
            context.user_data['last_interaction_task_id'] = task_id
        else:
            await update.message.reply_text(f"Ráº¥t tiáº¿c, cÃ³ lá»—i khi cáº­p nháº­t deadline cho ID {task_id}\\.")
    except ValueError:
        await update.message.reply_text("Lá»—i Ä‘á»c Ä‘á»‹nh dáº¡ng ngÃ y thÃ¡ng cá»§a deadline cÅ©.")

async def get_summary_flow(update: Update, context: ContextTypes.DEFAULT_TYPE, details: dict):
    """Táº¡o bÃ¡o cÃ¡o tÃ³m táº¯t cÃ´ng viá»‡c, tÃ¡ch biá»‡t viá»‡c hoÃ n thÃ nh vÃ  viá»‡c cÃ²n láº¡i."""
    period = details.get("period", "this_week")
    start_date, end_date = get_date_range_for_period(period)
    if not start_date: await update.message.reply_text("TÃ´i chÆ°a hiá»ƒu khoáº£ng thá»i gian báº¡n muá»‘n bÃ¡o cÃ¡o."); return
    period_text = {"today": "hÃ´m nay", "this_week": "tuáº§n nÃ y", "this_month": "thÃ¡ng nÃ y"}.get(period)
    await update.message.reply_text(f"Äang tá»•ng há»£p bÃ¡o cÃ¡o cho {period_text} (tá»« {start_date.strftime('%d/%m')} Ä‘áº¿n {end_date.strftime('%d/%m')})...")
    # Láº¥y viá»‡c Ä‘Ã£ hoÃ n thÃ nh trong tuáº§n (dá»±a vÃ o ngÃ y káº¿t thÃºc thá»±c táº¿)
    completed_filters = {
        "assign_ids": DEFAULT_ASSIGNEE, "status": "HoÃ n thÃ nh",
        "end_from": start_date.strftime('%d/%m/%Y'), "end_to": end_date.strftime('%d/%m/%Y')
    }
    completed_tasks_data = await get_tasks_data(filters_override=completed_filters)
    completed_tasks = completed_tasks_data.get("data", []) if completed_tasks_data else []
    # Láº¥y viá»‡c cÃ²n láº¡i trong tuáº§n (dá»±a vÃ o deadline dá»± kiáº¿n)
    remaining_filters = {
        "assign_ids": DEFAULT_ASSIGNEE, "status": "DOING",
        "end_plan_from": start_date.strftime('%d/%m/%Y'), "end_plan_to": end_date.strftime('%d/%m/%Y')
    }
    remaining_tasks_data = await get_tasks_data(filters_override=remaining_filters)
    remaining_tasks = remaining_tasks_data.get("data", []) if remaining_tasks_data else []
    # Táº¡o bÃ¡o cÃ¡o tá»•ng há»£p
    summary_message = f"ğŸ“Š *BÃ¡o cÃ¡o hiá»‡u suáº¥t {period_text}:*\n\n"
    summary_message += f"âœ… Báº¡n Ä‘Ã£ hoÃ n thÃ nh tá»•ng cá»™ng *{len(completed_tasks)}* cÃ´ng viá»‡c\\.\n"
    summary_message += f"â³ Báº¡n cÃ²n láº¡i *{len(remaining_tasks)}* cÃ´ng viá»‡c cáº§n lÃ m trong tuáº§n\\.\n\n"
    if completed_tasks:
        summary_message += "*Chi tiáº¿t cÃ¡c cÃ´ng viá»‡c Ä‘Ã£ hoÃ n thÃ nh:*\n"
        for task in completed_tasks: summary_message += f"\\- {escape_markdown(task['title'], version=2)}\n"
    if remaining_tasks:
        summary_message += "\n*Chi tiáº¿t cÃ¡c cÃ´ng viá»‡c cÃ²n láº¡i:*\n"
        for task in remaining_tasks: summary_message += f"\\- {escape_markdown(task['title'], version=2)}\n"
    await update.message.reply_text(summary_message, parse_mode=ParseMode.MARKDOWN_V2)

async def update_status_flow(update: Update, context: ContextTypes.DEFAULT_TYPE, details: dict):
    """Cáº­p nháº­t tráº¡ng thÃ¡i cho nhiá»u cÃ´ng viá»‡c báº±ng batching, cÃ³ kiá»ƒm tra sá»± tá»“n táº¡i cá»§a tá»«ng ID."""
    tasks_to_update_raw = details.get("tasks", [])
    if not tasks_to_update_raw: 
        await update.message.reply_text("TÃ´i khÃ´ng tÃ¬m tháº¥y cÃ´ng viá»‡c nÃ o khá»›p\\.")
        return
    
    # Láº¥y danh sÃ¡ch cÃ´ng viá»‡c má»™t láº§n duy nháº¥t Ä‘á»ƒ kiá»ƒm tra
    tasks_data = await get_tasks_data()
    if not tasks_data:
        await update.message.reply_text("Ráº¥t tiáº¿c, tÃ´i khÃ´ng thá»ƒ láº¥y danh sÃ¡ch cÃ´ng viá»‡c Ä‘á»ƒ kiá»ƒm tra.")
        return
    all_tasks = tasks_data.get("data", [])
    
    # --- CHUáº¨N Bá»Š BATCH ---
    tasks_to_batch = [] # Danh sÃ¡ch cÃ¡c cÃ´ng viá»‡c há»£p lá»‡ Ä‘á»ƒ cháº¡y batch
    failed_validation_ids = [] # Danh sÃ¡ch cÃ¡c ID khÃ´ng qua Ä‘Æ°á»£c bÆ°á»›c xÃ¡c thá»±c

    for task_info in tasks_to_update_raw:
        task_id_raw = task_info.get("task_id")
        new_status_key = task_info.get("new_status")

        # 1. XÃ¡c thá»±c kiá»ƒu dá»¯ liá»‡u
        try:
            if not task_id_raw or not new_status_key: continue
            task_id = int(task_id_raw)
            api_status_value = STATUS_MAP.get(new_status_key)
            if not api_status_value:
                failed_validation_ids.append(f"ID {task_id} (tráº¡ng thÃ¡i '{new_status_key}' khÃ´ng há»£p lá»‡)")
                continue
        except (ValueError, TypeError):
            failed_validation_ids.append(f"ID '{task_id_raw}' khÃ´ng há»£p lá»‡")
            continue

        # 2. XÃ¡c thá»±c sá»± tá»“n táº¡i cá»§a ID
        if not validate_task_id(task_id, all_tasks):
            failed_validation_ids.append(f"ID {task_id} (khÃ´ng tá»“n táº¡i)")
            continue

        # Náº¿u má»i thá»© há»£p lá»‡, thÃªm vÃ o danh sÃ¡ch Ä‘á»ƒ cháº¡y batch
        payload = {'status': api_status_value}
        tasks_to_batch.append((task_id, payload))
    
    # --- THá»°C THI BATCH VÃ€ Xá»¬ LÃ Káº¾T QUáº¢ ---
    updated_tasks = {}
    api_error_ids = []

    if tasks_to_batch:
        logger.info(f"Báº¯t Ä‘áº§u cháº¡y batch cáº­p nháº­t cho {len(tasks_to_batch)} cÃ´ng viá»‡c.")
        batch_results = await batch_update_tasks(tasks_to_batch)
        
        # DÃ¹ng zip Ä‘á»ƒ láº·p qua cáº£ tÃ¡c vá»¥ gá»‘c vÃ  káº¿t quáº£ cá»§a nÃ³
        for task, result in zip(tasks_to_batch, batch_results):
            task_id, payload = task
            
            if isinstance(result, Exception) or result is False:
                # Náº¿u káº¿t quáº£ lÃ  má»™t Exception hoáº·c False -> tÃ¡c vá»¥ tháº¥t báº¡i á»Ÿ API
                api_error_ids.append(str(task_id))
                logger.error(f"Lá»—i API khi batch update ID {task_id}: {result}")
            else:
                # TÃ¡c vá»¥ thÃ nh cÃ´ng
                status_value = payload['status']
                title = next((t['title'] for t in all_tasks if t['ID'] == task_id), f"ID {task_id}")
                if status_value not in updated_tasks: updated_tasks[status_value] = []
                updated_tasks[status_value].append(f"'{title}'")
                context.user_data['last_interaction_task_id'] = task_id

    # --- XÃ‚Y Dá»°NG VÃ€ Gá»¬I PHáº¢N Há»’I ---
    response_parts = []
    if updated_tasks:
        for status, titles in updated_tasks.items(): 
            response_parts.append(f"âœ… ÄÃ£ chuyá»ƒn {len(titles)} cv sang *{status}*: {escape_markdown(', '.join(titles), version=2)}")
    
    # Gá»™p táº¥t cáº£ cÃ¡c lá»—i (lá»—i xÃ¡c thá»±c vÃ  lá»—i API) vÃ o má»™t chá»—
    all_failed_ids = failed_validation_ids + api_error_ids
    if all_failed_ids: 
        response_parts.append(f"ğŸ”´ Má»™t sá»‘ cáº­p nháº­t tháº¥t báº¡i: {escape_markdown(', '.join(all_failed_ids), version=2)}")
    
    if response_parts: 
        await update.message.reply_text("\n\n".join(response_parts), parse_mode=ParseMode.MARKDOWN_V2)
    elif not tasks_to_batch:
        # TrÆ°á»ng há»£p khÃ´ng cÃ³ tÃ¡c vá»¥ nÃ o qua Ä‘Æ°á»£c vÃ²ng xÃ¡c thá»±c
        await update.message.reply_text("Ráº¥t tiáº¿c, khÃ´ng cÃ³ cÃ´ng viá»‡c nÃ o há»£p lá»‡ Ä‘á»ƒ cáº­p nháº­t.")

async def fill_task_details_flow(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user_answer = update.message.text
    pending_queue = context.user_data['pending_tasks_queue']
    current_task = pending_queue.pop(0)
    title = current_task['title']
    assignee = current_task.get('assignee') # Láº¥y assignee tá»« hÃ ng Ä‘á»£i náº¿u cÃ³
    end_plan = await ask_gemini_to_parse_date(user_answer)
    if end_plan:
        newly_created_ids, _ = await create_task_flow(update, context, {"tasks": [{'title': title, 'end_plan': end_plan, 'assignee': assignee}]})
        if newly_created_ids: context.user_data['last_interaction_task_id'] = newly_created_ids[-1]
    else:
        await update.message.reply_text("TÃ´i chÆ°a hiá»ƒu ngÃ y. Vui lÃ²ng thá»­ láº¡i (vd: 'thá»© 6 tuáº§n sau', '25/12').")
        pending_queue.insert(0, current_task)
    if pending_queue: await update.message.reply_text(f"Tiáº¿p theo, deadline cho '{pending_queue[0]['title']}' lÃ  khi nÃ o?")
    else: context.user_data.pop('pending_tasks_queue', None)

async def clarify_creation_flow(update: Update, context: ContextTypes.DEFAULT_TYPE, details: dict):
    context.user_data['clarification_needed'] = details
    existing_task = details.get("existing_task", {})
    await update.message.reply_text(f"TÃ´i tháº¥y cÃ³ viá»‡c ráº¥t giá»‘ng lÃ :\nğŸ”¹ *{escape_markdown(existing_task.get('title', ''), version=2)}* `(ID: {existing_task.get('ID')})`\n\nBáº¡n muá»‘n **cáº­p nháº­t** hay **táº¡o má»›i**?", parse_mode=ParseMode.MARKDOWN_V2)

async def handle_clarification_response(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user_answer = update.message.text.lower()
    clarification_data = context.user_data.pop('clarification_needed', None)
    if not clarification_data: return
    if "má»›i" in user_answer:
        await create_task_flow(update, context, {"tasks": [clarification_data.get("new_task_info", {})]})
    elif "cáº­p nháº­t" in user_answer or "cÅ©" in user_answer:
        await update.message.reply_text("ÄÃ£ hiá»ƒu. Báº¡n muá»‘n cáº­p nháº­t viá»‡c Ä‘Ã³ ntn? (vd: 'gia háº¡n 2 ngÃ y', 'xong rá»“i')")
        context.user_data['last_interaction_task_id'] = clarification_data.get("existing_task", {}).get("ID")
    else:
        await update.message.reply_text("Vui lÃ²ng cho biáº¿t báº¡n muá»‘n 'cáº­p nháº­t' hay 'táº¡o má»›i' nhÃ©.")
        context.user_data['clarification_needed'] = clarification_data

async def generic_reminder(context: ContextTypes.DEFAULT_TYPE):
    chat_id = context.job.chat_id
    tasks_data = await get_tasks_data()
    overload_warning = ""
    if tasks_data and tasks_data.get("data"):
        overdue_count = sum(1 for t in tasks_data["data"] if "QuÃ¡ háº¡n" in t.get('deadline_list', ''))
        due_today_count = sum(1 for t in tasks_data["data"] if "CÃ²n 0 ngÃ y" in t.get('deadline_list', ''))
        if overdue_count + due_today_count >= 3:
            overload_warning = f"\n\n*Cáº£nh bÃ¡o:* Báº¡n cÃ³ {overdue_count + due_today_count} cÃ´ng viá»‡c quÃ¡ háº¡n hoáº·c Ä‘áº¿n háº¡n hÃ´m nay. HÃ£y táº­p trung xá»­ lÃ½ nhÃ©!"
    message_text = format_tasks_message(tasks_data, title="ğŸ”” Nháº¯c nhá»Ÿ cÃ´ng viá»‡c cá»§a báº¡n:")
    question = "\n\nBáº¡n cÃ³ cáº§n tÃ´i há»— trá»£ gÃ¬ khÃ´ng?"
    await context.bot.send_message(chat_id=chat_id, text=message_text + overload_warning + question, parse_mode=ParseMode.MARKDOWN_V2)

async def set_reminders_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    chat_id = update.effective_chat.id
    try:
        times_str = context.args
        if not times_str: await update.message.reply_text("Sá»­ dá»¥ng: /set_reminders HH:MM HH:MM ..."); return
        reminder_times = [datetime.strptime(t, '%H:%M').time() for t in times_str]
        context.user_data['reminder_times'] = [t.strftime('%H:%M') for t in reminder_times]
        scheduler = context.application.job_queue
        for job in scheduler.get_jobs_by_name(f"reminder_{chat_id}"): job.schedule_removal()
        for i, t in enumerate(reminder_times):
            scheduler.run_daily(generic_reminder, time=t, days=tuple(range(5)), chat_id=chat_id, name=f"reminder_{chat_id}", job_kwargs={'misfire_grace_time': 3600})
        await update.message.reply_text(f"âœ… ÄÃ£ Ä‘áº·t lá»‹ch nháº¯c nhá»Ÿ vÃ o cÃ¡c giá»: {', '.join(context.user_data['reminder_times'])} hÃ ng ngÃ y tá»« Thá»© 2-6.")
    except (ValueError, IndexError): await update.message.reply_text("Äá»‹nh dáº¡ng thá»i gian khÃ´ng há»£p lá»‡. Vui lÃ²ng dÃ¹ng HH:MM.")

async def clear_reminders_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    chat_id = update.effective_chat.id
    scheduler = context.application.job_queue
    jobs_removed = sum(1 for job in scheduler.get_jobs_by_name(f"reminder_{chat_id}") if job.schedule_removal())
    if 'reminder_times' in context.user_data: del context.user_data['reminder_times']
    if jobs_removed > 0: await update.message.reply_text("âœ… ÄÃ£ xÃ³a táº¥t cáº£ lá»‹ch nháº¯c nhá»Ÿ cÃ¡ nhÃ¢n cá»§a báº¡n.")
    else: await update.message.reply_text("Báº¡n khÃ´ng cÃ³ lá»‹ch nháº¯c nhá»Ÿ nÃ o Ä‘á»ƒ xÃ³a.")

async def main():
    application = Application.builder().token(TELEGRAM_TOKEN).build()
    application.add_handler(CommandHandler('start', start))
    application.add_handler(CommandHandler('help', help_command))
    application.add_handler(CommandHandler('tasks', get_prioritized_tasks_flow))
    application.add_handler(CommandHandler('set_reminders', set_reminders_command))
    application.add_handler(CommandHandler('clear_reminders', clear_reminders_command))
    application.add_handler(MessageHandler(filters.TEXT & ~filters.COMMAND, handle_message))
    print("Bot Ä‘ang khá»Ÿi Ä‘á»™ng...")
    async with application:
        await application.initialize()
        await application.start()
        await application.updater.start_polling()
        print("Bot Ä‘Ã£ cháº¡y vá»›i bá»™ nÃ£o Ä‘iá»u phá»‘i v4.5! Sáºµn sÃ ng nháº­n lá»‡nh.")
        await asyncio.Event().wait()
if __name__ == '__main__':
    asyncio.run(main())